use serde::Deserialize;
use std::collections::BTreeMap;
use std::fs;
use std::path::PathBuf;

#[derive(Debug, Deserialize)]
struct AllowlistsFile {
    run_cmd: RunCmdConfig,
}

#[derive(Debug, Deserialize)]
struct RunCmdConfig {
    common: Vec<String>,
    by_tech: BTreeMap<String, Vec<String>>,
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let manifest_dir = PathBuf::from(std::env::var("CARGO_MANIFEST_DIR")?);
    let config_path = manifest_dir.join("config").join("allowlists.toml");

    println!("cargo:rerun-if-changed={}", config_path.display());

    let raw = fs::read_to_string(&config_path)?;
    let parsed: AllowlistsFile = toml::from_str(&raw)?;

    if parsed.run_cmd.common.is_empty() {
        return Err("run_cmd.common must not be empty".into());
    }

    for (tech, cmds) in &parsed.run_cmd.by_tech {
        if tech.trim().is_empty() {
            return Err("run_cmd.by_tech contains an empty tech key".into());
        }
        if cmds.is_empty() {
            return Err(format!("run_cmd.by_tech.{tech} must not be empty").into());
        }
    }

    let mut generated = String::new();
    generated.push_str("// @generated by build.rs from config/allowlists.toml\n");
    generated.push_str("pub const RUN_CMD_COMMON: &[&str] = &[\n");
    for cmd in &parsed.run_cmd.common {
        generated.push_str(&format!("    {cmd:?},\n"));
    }
    generated.push_str("];\n\n");

    generated.push_str("pub const RUN_CMD_TECH_KEYS: &[&str] = &[\n");
    for tech in parsed.run_cmd.by_tech.keys() {
        generated.push_str(&format!("    {tech:?},\n"));
    }
    generated.push_str("];\n\n");

    generated.push_str("#[must_use]\n");
    generated.push_str("pub fn run_cmd_for_tech(tech: &str) -> &'static [&'static str] {\n");
    generated.push_str("    match tech {\n");
    for (tech, cmds) in &parsed.run_cmd.by_tech {
        generated.push_str(&format!("        {tech:?} => &[\n"));
        for cmd in cmds {
            generated.push_str(&format!("            {cmd:?},\n"));
        }
        generated.push_str("        ],\n");
    }
    generated.push_str("        _ => &[],\n");
    generated.push_str("    }\n");
    generated.push_str("}\n");

    let out_dir = PathBuf::from(std::env::var("OUT_DIR")?);
    let out_file = out_dir.join("allowlists_generated.rs");
    fs::write(out_file, generated)?;

    Ok(())
}
